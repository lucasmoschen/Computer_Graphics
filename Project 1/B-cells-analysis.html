<!DOCTYPE html>
<html>
<head>
	<title> B Cell Analysis </title>
	<script type="text/javascript" src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async>
	</script>
	
</head>

<body>
	<h1> Transmissão Eletrônica Microscópica (Transmission Eletron Microscopic) </h1>
	<h2> Motivação </h2> 
	<h2> Introdução </h2>
	<h2> Imagens utilizadas </h2>
	<p> O primeiro processo que tive que fazer foi o de converter as imagens do banco de dados 
	no formato TIFF em imagens no formato PNG. Esse formato foi escolhido por sua flexibilidade 
	quanto à escolha do browser e por ser de código aberto. As imagens tinham resolução de cor de
	8 bits, então a conversão não sofreu grandes perdas. </p>
	<h2> Histogramas </h2>
	<p> Um histograma de uma imagem digital em tons de cinza é uma função discreta \( h(r_k) = n_k \), onde \(r_k\) é 
	o nível de cinza e \(n_k\) é o número de ocorrências na imagem. Em meus histogramas, tomarei ele normalizado. 
	Então, podemos tomar a frequência como uma probabilidade aproximada de ocorrência. A partir dessa informação, 
	algumas informações podem ser concluídas, como, por exemplo: a imagem é mais clara ou mais escura, a imagem tem 
	contraste alto ou baixo, etc. </p>
	<div id = "image_analysis1" style = "width: 1200px height: 400px">
		<div id = "black_white" style = "width: 600px height: 400px; float: left;">
			<canvas id = "black_white_image" width="600" height= "400"></canvas>
		</div>
		<div id = "bw_histogram" style = "width: 600px height: 400px; float: right;"></div>
	</div>
	
	<div id = "image_analysis2" style = "width: 1200px height: 400px">
		<div id = "black_white2" style = "width: 600px height: 400px; float: left;">
			<canvas id = "black_white_image2" width="600" height= "400"></canvas>
		</div>
		<div id = "bw_histogram2" style = "width: 600px height: 400px; float: right;"></div>
	</div>
	<canvas id = "space" width="35" height = "1"></canvas>
	<p> Observe que na primeira imagem, a coloração de tons mais escuros é predominante, o que faz com que 
	os componentes do histograma estejam mais concentrados à esquerda. Como o contraste também é baixo, os tons 
	tendem a se concentrar (descvio padrão baixo). Enquanto na segunda, os tons são mais distríbuidos. 
	Desta forma, a média aproxima-se do valor médio de uma distribuição uniforme. O contraste também é maior nessa imagem, por essa distribuição. 
	</p> 
	<h2> Equalização de Histogramas </h2>
	<p> Considere essas imagens de duas células B, obtidas pelo método de TEM. A primeira imagem apresenta uma configuração mais distribuída 
	entre os tons de cinza, enquanto a segunda apresenta uma concentração de brancos, como visto no histograma, e uma parte totalmente preta, 
	provavelmente devido a algum problema de obtenção da imagem. Nesse sentido, fica claro o interesse de fazer uma <b> equalização de histograma </b>, 
	para posteriores análises de dados. 
	</p>
<figure>
	<canvas id="cells_inicial" width="1300" height="600"></canvas>
	<figcaption>
		Imagem de duas células B. É observável a diferença entre as duas imagens, uma com uma distribuição de brancos muito maior do que a outra.
		A segunda imagem tem um problema de obtenção. O dado apresenta um grande ruído. 
	</figcaption>
</figure>

<div id="histogram1" style = "width:1300px height:512px">
  <div id = "cell1" style="width:650px; float:left;"></div>
  <div id = "cell2" style="width:650px; float:right;"></div>
</div>

<h3> Definição: uso da probabilidade </h3>
	<p>
	Seja \(r\) o nível de cinza de um determinado pixel. Por enquanto, utilizemos o fato de que \(0\leq r \leq 1\). Assim, 
	focamos nossa atenção em transformações do tipo \(s = T(r)\), que satisfazem a condição de ser monótona crescente no intervalo 
	específicado acima e \(0 \leq T(r) \leq 1\). Também é interessante que exista inversa para essa transformação. Note que a monotocidade 
	irá garantir que as cores mais escuras continuem dessa maneira, não abrindo precedentes para inversões de cores não desejadas 
	na análise. Note que estamos tratando essa transformação como contínua, não discreta. Desta maneira, vejamos o nível de cinza de um 
	pixel como uma variável aleatória no intervalo \([0,1]\). Seja \(p_r(r)\) a função densidade de probabilidade de \(r\). 
	Como \(s = T(r)\), uma propriedade da probabilidade diz que \(p_s(s) = p_r(r)\cdot |\frac{dr}{ds}|\).
	</p>
	<p> 
	Uma transformação bem com importância particular no processamento de imagens tem a forma \(s = T(r) = \int_0^r p_r(w) dw \). 
	Nesse caso, a distribuição de \(s\) será uma uniforme no intervalo. Agora, para o problema em questão, como estamos tratando de 
	valores discretos, tomaremos \(s_k = T(r_k) = \sum_{j=0}^k p_r(r_j) \), onde \(p_r(r_j) = \frac{n_j}{n} \) e \(k = 0,1,2,...255\).
	</p>
	<p> Então, a imagem processada é obtida através do mapeamento de cada pixel com seu pixel correspondente. A transformação é chamada de 
	equalização de histograma. Essa equalização espalha para o espectro completo da escala de cinza.
	</p>
	
<figure>
	<canvas id="first_equalization" width="1400" height="600"></canvas>
	<figcaption>
		Vemos na parte superior 4 imagens do banco de dados de células B em seu formato original. Abaixo, após a transformação supracitada, obtermos o resultado.
		Note que a primeira imagem tem pouca variação, pois essa transformação distribui melhor aas cores, entretanto, quando a imagem tem um histograma bem distribuído,
		O resultado é pouco diferente. 
	</figcaption>
</figure>

<h3> Histogram Matching </h3>
<p> Também conhecido como Histogram Specification. Quando utilizamos o método anterior para equalizar o histograma, vimos que isso pode ser 
automaticamente, produzindo uma imagem com histograma uniforme (Basta fazer o cálculo de \(p_s(s)\)). Entretanto, às vezes é interessante 
especificar a forma do histograma que desejamos que a imagem processada tenha. 
Assim, consideremos \(p_r(r)\) e \(p_z(z)\) PDFs, que representam a distribuição do histrograma, da imagem original e da imagem processada, 
respectivamente. Tomemos, então \(s\) de forma que \(s = T(r) = \int_0^r p_r(w) dw \) e definamos \(z\) com a propriedade \(G(z) = \int_0^z p_z(t) dt = s\).
Desta dorma, \(G(z) = T(r) \implies z = G^{-1}[T(r)]\), assumindo a existência da inversa de \(G\). Assim: (1) Obtenho \(T(r) \) \(G(z)\) como anteriormente. 
(2) Obtenho a transformação \(G^{-1}\) e (3) Obtenho a imagem de saída. 
</p>
<p> 
	Todavia, obter essas expressões analitícamente nem sempre é possível. Em contrapartida, podemos utilizar no caso discreto com algumas aproximações. 
	Façamos um primeiro exemplo com a imagem crítica descrita acima. Usaremos, como referência a distribuição do histograma da primeira imagem, pois ela 
	deixa bem visível a célula. 
</p>
<div id = "hist_matching1" style = "width: 1400px height: 500px">
	<div id = "images_matching1" style = "width: 600px height: 500px; float: left;">
		<canvas id = "imagesMatching1" width="500" height= "500"></canvas>
	</div>
	<div id = "histogram_matching1" style = "width: 600px height: 500px; float: right;"></div>
</div>
<div id = "hist_matching2" style = "width: 1400px height: 500px">
	<div id = "images_matching2" style = "width: 600px height: 500px; float: right;">
		<canvas id = "imagesMatching2" width="500" height= "500"></canvas>
	</div>
	<div id = "histogram_matching2" style = "width: 600px height: 500px; float: left;"></div>
</div>
<div id = "hist_matching3" style = "width: 1200px height: 500px">
	<div id = "images_matching3" style = "width: 600px height: 500px; float: left;">
		<canvas id = "imagesMatching3" width="500" height= "500"></canvas>
	</div>
	<div id = "histogram_matching3" style = "width: 600px height: 500px; float: right;"></div>
</div>
<canvas id = "nothing" width = "100" height = "5"></canvas>
<p> A diferença é notável. Porém, algo incomoda o modelo para mim: A área de preto, que agora se tornou cinza. Esse dado é dado perdido. Mais do que isso, 
Todo o entorno da imagem é desnecessário para a análise da célula. Por isso, vamos, posteriormente, recorrer a um método de <b> segmentação </b> para separar 
a célula de seu fundo. 
</p>

<script type = "text/javascript" src = "image_processing.js"></script>
<script type = "text/javascript" src = "load_image.js"></script>

</body>
</html>